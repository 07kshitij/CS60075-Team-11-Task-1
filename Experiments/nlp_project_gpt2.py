# -*- coding: utf-8 -*-
"""NLP Project GPT2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1M-ojY0UzbrRmcG3UBfK3Kb9fdzDmLPlV
"""

!pip install transformers
import numpy as np
import pandas as pd
import torch
import csv
from scipy import stats
from transformers import GPT2Tokenizer, GPT2ForSequenceClassification
import torch.nn as nn
import torch.optim as optim
from torchtext.legacy.data import Field, TabularDataset, BucketIterator, Iterator

TRAIN_DATAPATH = "https://raw.githubusercontent.com/MMU-TDMLab/CompLex/master/train/lcp_multi_train.tsv"
TEST_DATAPATH = "https://raw.githubusercontent.com/MMU-TDMLab/CompLex/master/test-labels/lcp_multi_test.tsv"
train_filepath = "/content/sample_data/train.csv"
test_filepath = "/content/sample_data/test.csv"

k = 5            # token append number

df_train = pd.read_csv(TRAIN_DATAPATH, sep = '\t', quotechar="'", quoting = csv.QUOTE_NONE)
df_test = pd.read_csv(TEST_DATAPATH, sep = '\t', quotechar="'", quoting = csv.QUOTE_NONE)
df_train['complexity'] = df_train['complexity'].astype(float)
df_test['complexity'] = df_test['complexity'].astype(float)
df_train = df_train.drop(['id', 'corpus', 'token'], axis = 1)
df_test = df_test.drop(['id', 'corpus', 'token'], axis = 1)
df_train = df_train[['complexity', 'sentence']]
df_test = df_test[['complexity', 'sentence']]
df_train.to_csv(train_filepath, index = False)
df_test.to_csv(test_filepath, index = False)
#df_token_train = df_token_train.apply(lambda row : tokenizer.tokenize("[CLS] " + row + " [SEP]"), axis = 1)
#df_token_test = df_token_test.apply(lambda row : tokenizer.tokenize("[CLS] " + row['token'] + " [SEP]"))

device = 'cuda'
batch_size = 4
num_epochs = 30

tokenizer = GPT2Tokenizer.from_pretrained("gpt2-medium")

UNK_INDEX = tokenizer.convert_tokens_to_ids(tokenizer.unk_token)

label = Field(sequential = False, use_vocab = False, batch_first = True, dtype = torch.float32)
text = Field(use_vocab = False, tokenize = tokenizer.encode, lower = False, include_lengths = False, pad_token = 0, unk_token = UNK_INDEX, batch_first = True)
fields = [('complexity', label), ('sentence', text)]
train = TabularDataset(path = train_filepath, format = 'csv', skip_header = True, fields = fields)
train_iter = BucketIterator(train, batch_size = batch_size, sort_key = lambda x: len(x.sentence), device = device, train = True)

test_label = Field(sequential = False, use_vocab = False, batch_first = True, dtype = torch.float32)
test_text = Field(use_vocab = False, tokenize = tokenizer.encode, lower = False, include_lengths = False, batch_first = True, pad_token = 0, unk_token = UNK_INDEX)
test_fields = [('complexity', test_label), ('sentence', test_text)]
test = TabularDataset(path = test_filepath, format = 'csv', skip_header = True, fields = test_fields)
test_iter = BucketIterator(test, batch_size = batch_size, sort_key = lambda x: len(x.sentence), device = device, train = False)

model = GPT2ForSequenceClassification.from_pretrained("gpt2-medium")
model.config.num_labels = 1
model.config.pad_token_id = 0
model.to(device)
criterion = nn.MSELoss()
optimizer = optim.Adam(model.parameters(), lr = 0.00001)
scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size = 5, gamma = 0.97)

def train_model(model, iterator):
    epoch_loss = 0.0
    epoch_acc = 0.0
    model.train()
    for batch in iterator:
        text = batch.sentence
        label = batch.complexity
        optimizer.zero_grad()
        output = model(text)                       
        logits = output.logits[:, : 1]                    # output gives 2 values of logits, not quite sure what are they
        logits = torch.sigmoid(torch.squeeze(logits))
        try:
            predicted.extend(logits.tolist())
            labels.extend(label.tolist())
            loss = criterion(label, logits)
            loss.backward()
            optimizer.step()
            epoch_loss += loss.item()
        except TypeError:
            pass
    return epoch_loss / len(iterator)

def test_model(model, iterator):
    model.eval()
    with torch.no_grad():
        for batch in iterator:
            text = batch.sentence
            label = batch.complexity
            output = model(text)
            logits = output.logits[:, : 1]                    # gives 2 values of logits, not quite sure what are they
            logits = torch.sigmoid(torch.squeeze(logits))
            try:
                test_predicted.extend(logits.tolist())
                test_labels.extend(label.tolist())
            except TypeError:
                pass

def calculate_metrics(y, y_hat):
    vx = y.astype(float)
    vy = y_hat.astype(float)
    pearsonR = np.corrcoef(vx, vy)[0, 1]
    spearmanRho = stats.spearmanr(vx, vy)
    MSE = np.mean((vx - vy) ** 2)
    MAE = np.mean(np.absolute(vx - vy))
    RSquared = (pearsonR ** 2)

    print("Pearson's R: {}".format(pearsonR))
    print("Spearman's rho: {}".format(spearmanRho))
    print("R Squared: {}".format(RSquared))
    print("MSE: {}".format(MSE))
    print("MAE: {}".format(MAE))

for epoch in range(num_epochs):
    labels = []
    predicted = []
    train_loss = train_model(model, train_iter)
    print(f'\t Epoch: {epoch + 1} | Train Loss: {train_loss: }')
    print("------Metrics for train------")
    calculate_metrics(np.array(labels), np.array(predicted))
    test_labels = []
    test_predicted = []
    test_model(model, test_iter)
    print("------Metrics for test-------")
    calculate_metrics(np.array(test_labels), np.array(test_predicted))
    scheduler.step()

#shape of attentions = num_epochs * (iterator_size / batch_size) * batch_size * MAX_SEQ_LEN * MAX_SEQ_LEN

#batch = next(iter(train_iter))

#batch.complexity